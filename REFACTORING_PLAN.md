# Hexagonal Architecture Refactoring Plan

This document outlines the complete plan for refactoring the Password Exchange application to use hexagonal (ports and adapters) architecture.

## Overview

**Goal:** Transform the current monolithic command structure into a clean hexagonal architecture with clear separation of concerns, improved testability, and better maintainability.

**Approach:** Incremental refactoring maintaining backward compatibility throughout the process.

---

## âœ… COMPLETED PHASES

### Phase 1: Create Hexagonal Directory Structure âœ…
**Status:** COMPLETED

Created the foundation directory structure following hexagonal architecture principles:

```
app/
â”œâ”€â”€ internal/                    # Private application code
â”‚   â”œâ”€â”€ shared/                  # Cross-cutting concerns
â”‚   â”‚   â”œâ”€â”€ config/             # Configuration management
â”‚   â”‚   â”œâ”€â”€ logging/            # Structured logging (placeholder)
â”‚   â”‚   â””â”€â”€ validation/         # Common validation utilities
â”‚   â””â”€â”€ domains/                # Business domains
â”‚       â”œâ”€â”€ message/            # Core message sharing domain
â”‚       â”œâ”€â”€ encryption/         # Cryptographic operations domain
â”‚       â”œâ”€â”€ storage/            # Data persistence domain
â”‚       â””â”€â”€ notification/       # Communication domain
â””â”€â”€ pkg/                        # Public interfaces
    â”œâ”€â”€ pb/                     # Generated protobuf code
    â””â”€â”€ clients/                # Service clients
```

Each domain follows the hexagonal pattern:
- `domain/` - Business entities & rules
- `ports/primary/` - Inbound interfaces (web, gRPC)
- `ports/secondary/` - Outbound interfaces (database, external services)
- `adapters/primary/` - Inbound implementations
- `adapters/secondary/` - Outbound implementations

### Phase 2: Move Shared Components âœ…
**Status:** COMPLETED

Relocated shared utilities and configuration:
- âœ… `app/config/` â†’ `app/internal/shared/config/`
- âœ… `app/commons/` â†’ `app/internal/shared/validation/` (renamed to env.go)
- âœ… `app/message/` â†’ `app/internal/domains/message/domain/entities.go`
- âœ… Updated all import paths across codebase
- âœ… Verified builds work after moves

### Phase 3: Organize Generated Code âœ…
**Status:** COMPLETED

Moved protobuf files to clean pkg structure:
- âœ… `app/databasepb/` â†’ `app/pkg/pb/database/`
- âœ… `app/encryptionpb/` â†’ `app/pkg/pb/encryption/`
- âœ… `app/messagepb/` â†’ `app/pkg/pb/message/`
- âœ… Updated import paths in all consuming files
- âœ… Updated build scripts for new structure

### Phase 4: Update Build System âœ…
**Status:** COMPLETED

Updated build scripts and Docker configuration:
- âœ… Modified `test-build.sh` for new protobuf generation paths
- âœ… Verified Docker builds work with new structure
- âœ… Updated documentation (CLAUDE.md)
- âœ… Added proper .gitignore entries
- âœ… All builds tested and working

### Phase 5.3: Storage Domain Implementation âœ…
**Status:** COMPLETED

Successfully extracted Storage domain with complete hexagonal architecture:

**Domain Layer:**
- âœ… `domain/entities.go` - Message entity and MessageRepository interface
- âœ… `domain/service.go` - Business logic with validation and error handling
- âœ… `domain/errors.go` - Domain-specific error definitions

**Ports (Interfaces):**
- âœ… `ports/primary/service.go` - StorageServicePort interface for inbound operations
- âœ… MessageRepository interface in domain for outbound data access

**Adapters:**
- âœ… `adapters/secondary/mysql/adapter.go` - MySQL implementation of MessageRepository
- âœ… `adapters/primary/grpc/server.go` - gRPC server implementing protobuf interface

**Integration:**
- âœ… Updated `cmd/database/database2.go` to use hexagonal architecture
- âœ… Dependency injection with proper service composition
- âœ… Backward compatibility maintained
- âœ… All builds and tests passing
- âœ… Successfully deployed and tested

**Key Achievements:**
- Clean separation of business logic from infrastructure
- Testable domain logic with clear interfaces
- Database technology independence through repository pattern
- gRPC presentation layer properly decoupled
- Foundation established for remaining domain extractions

### Phase 5.2: Encryption Domain Implementation âœ…
**Status:** COMPLETED

Successfully extracted Encryption domain with complete hexagonal architecture:

**Domain Layer:**
- âœ… `domain/entities.go` - EncryptionKey, encryption/decryption entities with KeyGenerator interface
- âœ… `domain/service.go` - AES-GCM cryptographic business logic with comprehensive error handling
- âœ… `domain/errors.go` - Domain-specific error definitions for encryption operations

**Ports (Interfaces):**
- âœ… `ports/primary/service.go` - EncryptionServicePort interface for inbound operations
- âœ… `ports/secondary/keygen.go` - KeyGeneratorPort interface for outbound key generation

**Adapters:**
- âœ… `adapters/secondary/memory/keygen.go` - In-memory key generation using crypto/rand
- âœ… `adapters/primary/grpc/server.go` - gRPC server implementing protobuf MessageService interface

**Integration:**
- âœ… Updated `cmd/encryption/encryption2.go` to use hexagonal architecture
- âœ… Dependency injection with proper service composition
- âœ… Backward compatibility maintained with legacy server methods
- âœ… Context.Context parameters added for consistency and best practices
- âœ… All builds and tests passing
- âœ… Successfully deployed and tested via PR #341

**Key Achievements:**
- Clean separation of cryptographic business logic from infrastructure concerns
- Testable encryption service with clear interfaces and comprehensive error handling
- Technology independence through adapter pattern for key generation
- gRPC presentation layer properly decoupled from domain logic
- Context propagation following Go best practices
- Foundation ready for comprehensive unit and integration testing

---

## ðŸš§ PLANNED PHASES

### Phase 5: Extract Domain Logic
**Status:** IN PROGRESS (Storage âœ…, Encryption âœ… COMPLETED)
**Priority:** HIGH

Extract business logic from current services into domain layers:

#### 5.1: Message Domain
- [ ] Extract message validation logic from web handlers
- [ ] Create message sharing business rules
- [ ] Define message lifecycle management
- [ ] Move from `cmd/web/forms.go` to `internal/domains/message/domain/`

#### 5.2: Encryption Domain âœ…
- [x] Extract encryption algorithms from `cmd/encryption/encryption2.go`
- [x] Create key generation and management logic with KeyGenerator interface
- [x] Define cryptographic policies and error handling in domain layer
- [x] Move to `internal/domains/encryption/domain/`
- [x] Implement hexagonal architecture with ports and adapters
- [x] Create memory-based secondary adapter for key generation
- [x] Create gRPC primary adapter implementing protobuf interface
- [x] Maintain backward compatibility with legacy server methods
- [x] Add context.Context parameters for consistency and best practices
- [x] Test and deploy successfully

#### 5.3: Storage Domain âœ…
- [x] Extract repository patterns from `cmd/database/database2.go`
- [x] Create data access abstractions with MessageRepository interface
- [x] Define query composition logic in MySQL adapter
- [x] Move to `internal/domains/storage/domain/`
- [x] Implement hexagonal architecture with ports and adapters
- [x] Create MySQL secondary adapter
- [x] Create gRPC primary adapter
- [x] Maintain backward compatibility
- [x] Test and deploy successfully

#### 5.4: Notification Domain
- [ ] Extract email logic from `cmd/email/`
- [ ] Create notification templates and routing
- [ ] Define delivery policies
- [ ] Move to `internal/domains/notification/domain/`

### Phase 6: Define Ports (Interfaces)
**Status:** PENDING
**Priority:** HIGH

Create port interfaces for each domain:

#### 6.1: Primary Ports (Inbound)
- [ ] `message/ports/primary/web.go` - HTTP handlers interface
- [ ] `message/ports/primary/grpc.go` - gRPC server interface
- [ ] `encryption/ports/primary/service.go` - Encryption service interface
- [ ] `storage/ports/primary/service.go` - Storage service interface
- [ ] `notification/ports/primary/service.go` - Notification service interface

#### 6.2: Secondary Ports (Outbound)
- [ ] `message/ports/secondary/storage.go` - Storage interface
- [ ] `message/ports/secondary/encryption.go` - Encryption interface  
- [ ] `message/ports/secondary/notification.go` - Notification interface
- [ ] `storage/ports/secondary/database.go` - Database interface
- [ ] `encryption/ports/secondary/keystore.go` - Key storage interface
- [ ] `notification/ports/secondary/mailer.go` - Email sending interface
- [ ] `notification/ports/secondary/queue.go` - Message queue interface

### Phase 7: Implement Adapters
**Status:** PENDING
**Priority:** HIGH

Create adapter implementations:

#### 7.1: Secondary Adapters (Infrastructure)
- [ ] `storage/adapters/secondary/mysql/` - MySQL database adapter
- [ ] `encryption/adapters/secondary/memory/` - In-memory key storage
- [ ] `notification/adapters/secondary/smtp/` - SMTP email adapter
- [ ] `notification/adapters/secondary/rabbitmq/` - RabbitMQ adapter
- [ ] `message/adapters/secondary/grpc_clients/` - External service clients

#### 7.2: Primary Adapters (Presentation)
- [ ] `message/adapters/primary/web/` - HTTP/Gin web adapter
- [ ] `message/adapters/primary/grpc/` - gRPC server adapter
- [ ] `encryption/adapters/primary/grpc/` - Encryption gRPC server
- [ ] `storage/adapters/primary/grpc/` - Storage gRPC server
- [ ] `notification/adapters/primary/consumer/` - RabbitMQ consumer

### Phase 8: Move Static Assets
**Status:** PENDING
**Priority:** MEDIUM

Relocate web-specific assets to appropriate domain:
- [ ] `app/templates/` â†’ `message/adapters/primary/web/templates/`
- [ ] `app/assets/` â†’ `message/adapters/primary/web/assets/`
- [ ] Update Docker and build scripts

### Phase 9: Create Service Clients
**Status:** PENDING
**Priority:** MEDIUM

Implement reusable service clients:
- [ ] `pkg/clients/encryption.go` - Encryption service client
- [ ] `pkg/clients/storage.go` - Storage service client
- [ ] Update inter-service communication

### Phase 10: Wire Dependencies
**Status:** PENDING
**Priority:** HIGH

Implement dependency injection:
- [ ] Create application assemblers for each domain
- [ ] Wire ports to adapters with dependency injection
- [ ] Update main.go to use hexagonal structure
- [ ] Simplify cmd/ to just wire domains together

### Phase 11: Testing Strategy
**Status:** PENDING
**Priority:** HIGH

Implement comprehensive testing:
- [ ] Unit tests for domain logic (isolated)
- [ ] Integration tests for adapters (with real implementations)
- [ ] Contract tests for ports (verify implementations)
- [ ] End-to-end tests for complete workflows

### Phase 12: Documentation & Examples
**Status:** PENDING
**Priority:** MEDIUM

Create comprehensive documentation:
- [ ] Architecture decision records (ADRs)
- [ ] Domain interaction diagrams
- [ ] Developer onboarding guide
- [ ] Testing examples and patterns

---

## Benefits Achieved So Far

âœ… **Clean Code Organization** - Clear separation between business logic, infrastructure, and interfaces
âœ… **Build System Compatibility** - All existing build processes work with new structure
âœ… **Backward Compatibility** - No breaking changes to existing functionality
âœ… **Documentation** - Architecture guidance in CLAUDE.md
âœ… **Testability Foundation** - Structure ready for comprehensive testing
âœ… **Technology Independence** - Generated code separated from business logic
âœ… **Hexagonal Architecture Implementation** - Storage and Encryption domains fully extracted with proper ports and adapters
âœ… **Domain-Driven Design** - Business logic separated from infrastructure concerns across multiple domains
âœ… **Dependency Injection** - Clean service composition with interface-based dependencies
âœ… **Repository Pattern** - Data access abstraction with MySQL implementation
âœ… **Cryptographic Abstraction** - Encryption business logic separated from infrastructure with AES-GCM implementation
âœ… **Context Propagation** - Consistent context.Context usage following Go best practices

## Benefits After Completion

ðŸŽ¯ **Independent Deployability** - Each domain can be deployed separately
ðŸŽ¯ **Technology Flexibility** - Easy to swap databases, frameworks, etc.
ðŸŽ¯ **Enhanced Testability** - Mock adapters for isolated unit testing
ðŸŽ¯ **Clear Boundaries** - Explicit separation of concerns
ðŸŽ¯ **Maintainability** - Changes in one domain don't affect others
ðŸŽ¯ **Team Scalability** - Different teams can own different domains

---

## Migration Strategy

**Incremental Approach:**
1. Extract one domain at a time (start with least coupled)
2. Create tests for ports before implementing adapters  
3. Keep old structure working during migration
4. Validate each step with comprehensive testing

**Recommended Order:**
1. âœ… Storage domain (most foundational) - COMPLETED
2. âœ… Encryption domain (clear boundaries) - COMPLETED 
3. Notification domain (fewer dependencies) - NEXT
4. Message domain (most complex, do last) - REMAINING

**Risk Mitigation:**
- Each phase can be done independently
- Rollback capability at each step
- Maintain existing functionality throughout
- Comprehensive testing at each milestone